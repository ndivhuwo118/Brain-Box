// localtunnel@2.0.2 downloaded from https://ga.jspm.io/npm:localtunnel@2.0.2/localtunnel.js

import*as t from"url";import*as e from"events";import*as o from"axios";import*as s from"debug";import*as n from"fs";import*as r from"net";import*as l from"tls";import*as c from"stream";var a="default"in c?c.default:c;var i={};const{Transform:u}=a;class HeaderHostTransformer$1 extends u{constructor(t={}){super(t);this.host=t.host||"localhost";this.replaced=false}_transform(t,e,o){o(null,this.replaced?t:t.toString().replace(/(\r\n[Hh]ost: )\S+/,((t,e)=>{this.replaced=true;return e+this.host})))}}i=HeaderHostTransformer$1;var h=i;var d="default"in e?e.default:e;var p="default"in s?s.default:s;var m="default"in n?n.default:n;var f="default"in r?r.default:r;var _="default"in l?l.default:l;var v={};const{EventEmitter:g}=d;const y=p("localtunnel:client");const w=m;const E=f;const x=_;const C=h;v=class TunnelCluster extends g{constructor(t={}){super(t);this.opts=t}open(){const t=this.opts;const e=t.remote_ip||t.remote_host;const o=t.remote_port;const s=t.local_host||"localhost";const n=t.local_port;const r=t.local_https?"https":"http";const l=t.allow_invalid_cert;y("establishing tunnel %s://%s:%s <> %s:%s",r,s,n,e,o);const c=E.connect({host:e,port:o});c.setKeepAlive(true);c.on("error",(t=>{y("got remote connection error",t.message);"ECONNREFUSED"===t.code&&this.emit("error",new Error(`connection refused: ${e}:${o} (check your firewall settings)`));c.end()}));const connLocal=()=>{if(c.destroyed){y("remote destroyed");this.emit("dead");return}y("connecting locally to %s://%s:%d",r,s,n);c.pause();l&&y("allowing invalid certificates");const getLocalCertOpts=()=>l?{rejectUnauthorized:false}:{cert:w.readFileSync(t.local_cert),key:w.readFileSync(t.local_key),ca:t.local_ca?[w.readFileSync(t.local_ca)]:void 0};const e=t.local_https?x.connect({host:s,port:n,...getLocalCertOpts()}):E.connect({host:s,port:n});const remoteClose=()=>{y("remote close");this.emit("dead");e.end()};c.once("close",remoteClose);e.once("error",(t=>{y("local error %s",t.message);e.end();c.removeListener("close",remoteClose);if("ECONNREFUSED"!==t.code)return c.end();setTimeout(connLocal,1e3)}));e.once("connect",(()=>{y("connected locally");c.resume();let o=c;if(t.local_host){y("transform Host header to %s",t.local_host);o=c.pipe(new C({host:t.local_host}))}o.pipe(e).pipe(c);e.once("close",(t=>{y("local connection closed [%s]",t)}))}))};c.on("data",(t=>{const e=t.toString().match(/^(\w+) (\S+)/);e&&this.emit("request",{method:e[1],path:e[2]})}));c.once("connect",(()=>{this.emit("open",c);connLocal()}))}};var S=v;var b="default"in t?t.default:t;var T="default"in e?e.default:e;var k="default"in o?o.default:o;var H="default"in s?s.default:s;var U={};const{parse:$}=b;const{EventEmitter:F}=T;const j=k;const L=H("localtunnel:client");const N=S;U=class Tunnel extends F{constructor(t={}){super(t);this.opts=t;this.closed=false;this.opts.host||(this.opts.host="https://localtunnel.me")}_getInfo(t){const{id:e,ip:o,port:s,url:n,cached_url:r,max_conn_count:l}=t;const{host:c,port:a,local_host:i}=this.opts;const{local_https:u,local_cert:h,local_key:d,local_ca:p,allow_invalid_cert:m}=this.opts;return{name:e,url:n,cached_url:r,max_conn:l||1,remote_host:$(c).hostname,remote_ip:o,remote_port:s,local_port:a,local_host:i,local_https:u,local_cert:h,local_key:d,local_ca:p,allow_invalid_cert:m}}_init(t){const e=this.opts;const o=this._getInfo.bind(this);const s={responseType:"json"};const n=`${e.host}/`;const r=e.subdomain;const l=n+(r||"?new");(function getUrl(){j.get(l,s).then((e=>{const s=e.data;L("got tunnel information",e.data);if(200!==e.status){const e=new Error(s&&s.message||"localtunnel server returned an error, please try again");return t(e)}t(null,o(s))})).catch((t=>{L(`tunnel server offline: ${t.message}, retry 1s`);return setTimeout(getUrl,1e3)}))})()}_establish(t){this.setMaxListeners(t.max_conn+(F.defaultMaxListeners||10));this.tunnelCluster=new N(t);this.tunnelCluster.once("open",(()=>{this.emit("url",t.url)}));this.tunnelCluster.on("error",(t=>{L("got socket error",t.message);this.emit("error",t)}));let e=0;this.tunnelCluster.on("open",(t=>{e++;L("tunnel open [total: %d]",e);const closeHandler=()=>{t.destroy()};if(this.closed)return closeHandler();this.once("close",closeHandler);t.once("close",(()=>{this.removeListener("close",closeHandler)}))}));this.tunnelCluster.on("dead",(()=>{e--;L("tunnel dead [total: %d]",e);this.closed||this.tunnelCluster.open()}));this.tunnelCluster.on("request",(t=>{this.emit("request",t)}));for(let e=0;e<t.max_conn;++e)this.tunnelCluster.open()}open(t){this._init(((e,o)=>{if(e)return t(e);this.clientId=o.name;this.url=o.url;o.cached_url&&(this.cachedUrl=o.cached_url);this._establish(o);t()}))}close(){this.closed=true;this.emit("close")}};var q=U;var I={};const D=q;I=function localtunnel(t,e,o){const s="object"===typeof t?t:{...e,port:t};const n="object"===typeof t?e:o;const r=new D(s);if(n){r.open((t=>t?n(t):n(null,r)));return r}return new Promise(((t,e)=>r.open((o=>o?e(o):t(r)))))};var M=I;export{M as default};

